"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createIPXHandler = void 0;
const path_1 = require("path");
const os_1 = require("os");
const ipx_1 = require("ipx");
const functions_1 = require("@netlify/functions");
const ufo_1 = require("ufo");
const etag_1 = __importDefault(require("etag"));
const http_1 = require("./http");
const utils_1 = require("./utils");
function createIPXHandler({ cacheDir = (0, path_1.join)((0, os_1.tmpdir)(), 'ipx-cache'), basePath = '/_ipx/', propsEncoding, bypassDomainCheck, remotePatterns, responseHeaders, ...opts } = {}) {
    const ipx = (0, ipx_1.createIPX)({ ...opts, dir: (0, path_1.join)(cacheDir, 'cache') });
    if (!basePath.endsWith('/')) {
        basePath = `${basePath}/`;
    }
    const handler = async (event, _context) => {
        const host = event.headers.host;
        const protocol = event.headers['x-forwarded-proto'] === 'https' ? 'https' : 'http';
        let domains = opts.domains || [];
        const remoteURLPatterns = remotePatterns || [];
        const requestEtag = event.headers['if-none-match'];
        const url = event.path.replace(basePath, '');
        // eslint-disable-next-line prefer-const
        let [modifiers = '_', ...segments] = url.split('/');
        let id = decodeURIComponent(segments.join('/'));
        if (propsEncoding === 'base64') {
            const params = (0, utils_1.decodeBase64Params)(url);
            if (params.error) {
                return {
                    statusCode: 400,
                    body: params.error
                };
            }
            id = params.id;
            modifiers = params.modifiers;
        }
        const requestHeaders = {};
        const isLocal = !id.startsWith('http');
        if (isLocal) {
            id = `${protocol}://${host}${id.startsWith('/') ? '' : '/'}${id}`;
            if (event.headers.cookie) {
                requestHeaders.cookie = event.headers.cookie;
            }
            if (event.headers.authorization) {
                requestHeaders.authorization = event.headers.authorization;
            }
        }
        else {
            // Parse id as URL
            const parsedUrl = (0, ufo_1.parseURL)(id, 'https://');
            // Check host
            if (!parsedUrl.host) {
                return {
                    statusCode: 403,
                    body: 'Hostname is missing: ' + id
                };
            }
            if (!bypassDomainCheck) {
                let domainAllowed = false;
                if (domains.length > 0) {
                    if (typeof domains === 'string') {
                        domains = domains.split(',').map(s => s.trim());
                    }
                    const hosts = domains.map(domain => (0, ufo_1.parseURL)(domain, 'https://').host);
                    if (hosts.includes(parsedUrl.host)) {
                        domainAllowed = true;
                    }
                }
                if (remoteURLPatterns.length > 0) {
                    const matchingRemotePattern = remoteURLPatterns.find((remotePattern) => {
                        return (0, utils_1.doPatternsMatchUrl)(remotePattern, parsedUrl);
                    });
                    if (matchingRemotePattern) {
                        domainAllowed = true;
                    }
                }
                if (!domainAllowed) {
                    // eslint-disable-next-line no-console
                    console.log(`URL not on allowlist. Values provided are:
            domains: ${JSON.stringify(domains)}
            remotePatterns: ${JSON.stringify(remoteURLPatterns)}
          `);
                    return {
                        statusCode: 403,
                        body: 'URL not on allowlist: ' + id
                    };
                }
            }
        }
        const { response, cacheKey, responseEtag } = await (0, http_1.loadSourceImage)({
            cacheDir,
            url: id,
            requestEtag,
            modifiers,
            isLocal,
            requestHeaders
        });
        if (response) {
            return response;
        }
        const res = await (0, ipx_1.handleRequest)({
            url: `/${modifiers}/${cacheKey}`,
            headers: event.headers
        }, ipx);
        const body = typeof res.body === 'string' ? res.body : res.body.toString('base64');
        res.headers.etag = responseEtag || (0, etag_1.default)(body);
        delete res.headers['Last-Modified'];
        if (requestEtag && requestEtag === res.headers.etag) {
            return {
                statusCode: 304,
                message: 'Not Modified'
            };
        }
        if (responseHeaders) {
            for (const [header, value] of Object.entries(responseHeaders)) {
                res.headers[header] = value;
            }
        }
        return {
            statusCode: res.statusCode,
            message: res.statusMessage,
            headers: res.headers,
            isBase64Encoded: typeof res.body !== 'string',
            body
        };
    };
    return (0, functions_1.builder)(handler);
}
exports.createIPXHandler = createIPXHandler;
